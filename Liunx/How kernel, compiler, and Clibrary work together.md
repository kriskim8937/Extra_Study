## Kernel
> The kernel is the core of an operating system. In a traditional design, it is responsible for memory management, I/O, interrupt handling, 
and various other things. And even while some modern designs like Microkernels or Exokernels move several of these services into user space, this matters little in the scope of this document. The kernel makes its services available through a set of system calls; how they are called and what they do exactly differs from kernel to kernel.
## C Library
> One thing up front: When you begin working on your kernel, you do not have a C library available. You have to provide everything yourself,
except a few pieces provided by the compiler itself. You will also have to port an existing C library or write one yourself. The C library 
implements the standard C functions (i.e., the things declared in <stdlib.h>, <math.h>, <stdio.h> etc.) and provides them in binary form suitable for linking with user-space applications. In addition to standard C functions (as defined in the ISO standard), a C library might (and usually does) implement further functionality, which might or might not be defined by some standard. The standard C library says nothing about networking, for example. For Unix-like systems, the POSIX standard defines what is expected from a C library; other systems might differ fundamentally. It should be noted that, in order to implement its functionality, the C library must call kernel functions. So, for your own OS, you can of course take a ready-made C library and just recompile it for your OS - but that requires that you tell the library how to call your kernel functions, and your kernel to actually provide those functions. A more elaborate example is available in Library Calls or, you can use an existing C Library or create your own C Library.
## Compiler/Assembler
An Assembler takes (plaintext) source code and turns it into (binary) machine code; more precisely, it turns the source into object code, which contains additional information like symbol names, relocation information etc. 
A compiler takes higher-level language source code, and either directly turns it into object code, or (as is the case with GCC) turns it into Assembler source code and invokes an Assembler for the final step. 
The resulting object code does not yet contain any code for standard functions called. If you included e.g. <stdio.h> and used printf(), the object code will merely contain a reference stating that a function named printf() (and taking a const char * and a number of unnamed arguments as parameters) must be linked to the object code in order to receive a complete executable. 
Some compilers use standard library functions internally, which might result in object files referencing e.g. memset() or memcpy() even though you did not include the header or used a function of this name. You will have to provide an implementation of these functions to the linker, or the linking will fail. The GCC freestanding environment expects only the functions memset(), memcpy(), memcmp(), and memmove(), as well as the libgcc library. Some advanced operations (e.g. 64-bits divisions on a 32-bits system) might involve compiler-internal functions. For GCC, those functions are residing in libgcc. The content of this library is agnostic of what OS you use, and it won't taint your compiled kernel with licensing issues of whatever sort.
## Linker
